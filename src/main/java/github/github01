Local Repo Olusturma:
git init komutu kullanildiginda proje klasorunde .git klasoru olusturulur. Bu klasor git’in alt yapisini olusturacak klasordur.
Lokaldeyken version control sistemini nasil devreye aliriz? git init komutu bu isi yapiyor. Bu komutu kullaninca .git isimli klasor olusuyor. Ancak git init komutunu kulanirken cok dikkatli olmali. Neyi repository’e cevireceksek onun icinde olmaliyiz. Terminalde desktop’da mi yoksa desktop uzerindeki uzerinde calisacagimiz klasorde miyiz onu control etmeliyiz. Repoya cevirme islemini biz desktop icindeyken yaparsak desktop’daki tum klasorleri bir repository icine alma ihtimalimiz var. Ancak klasorun icinde isek problem olmaz. Sifirdan klasoru terminalde actigimizda zaten bizi dogrudan klasorun icinde tutuyor. Terminali kapatip, new terminal’e basinca yine ana klasorumuz icinde oldugumuzu bize gosteriyor. Ancak biz klasor icindeki bir baska dosya icine girmek isteyebiliriz. Calismamizi orada gerceklestirebiliriz. Iste o dosyaya ulasmak istersek soyle yazmaliyiz; cd ve sonrasinda bir bosluk ve dosyamizin ismini eklemeliyiz.
Diyelim ki bizim klasorumuzun adi GIT01, onun icinde new folder’a tiklayarak yeni bir dosya actik, app1 isimli. Bunu icin Terminalde cd app1 yazip enter’a basinca desktop\GIT01\app1’I gorururuz.Biz repro’yu bu app1 icinde yapmak istedik ve cd app1 yazarak app1 icine girdik. Geri gelmek icin cd ..
Yazmamiz gerekir. Bunu yapinca desktop\GIT01’I gorduk. Yani artik GIT01 icindeyiz. Tekrar app1’e gelmek icin cd app1 yazmaliyiz terminal icinde. Artik git init komutunu kullanabiliriz. Biz app1 klasoru icindeyiz. Bundan eminiz. git init yazip enter’a basinca bize bos bir Git repository’si olustugunu yazar. (initialized empty Git repository in…One Drive\Desktop\GIT01\app1\ .git) Yani app1 klasoru icinde .git isimli bir klasor olusmus oldu. Artik herseyi, versiyonlari bu gizli klasorde tutacak. Burada bir repo olusturmus olduk. git init bir kere yapilir. Ancak baska bir proje icin calisirken o yeni proje icin de bir kere git init yapilir. Tekrarlanmaz.
Projeye lokalden ya da remote’dan baslayabiliriz. Lokalede bilgisayarimizda bir proje baslatip, onu gelistirdikce onu github’a yonlendirebiliriz ya da github’da baslangicta bir repository olusturup, projemize orada baslayabiliriz.
Bireysel olarak olusturdugumuz projelerimiz icin lokalde baslayabiliriz. Ancak halihazirda baslatilmis bir proje uzerinde calismamiz halinde boyle bir proje remote’da repository olarak baslatilmis olur ve daha sonra biz bu projeyi kendi lokalimize aliriz.
Lokalde olusturdugumuz projeyi VKS’ye tabi tutmak istersek, projemizin oldugu dosya icinde isminin yazili oldugu dosya yolu olarak sayilan kismi silip yerine cmd yazip enter yapinca terminal aciliyor. Yani terminal o dosyamiz icinden acilmis olur.
Terminalde cd desktop yazinca desktop’a git demis oluruz, oraya gider ve devaminda cd GitProject01 yazarsak desktop icindeki projemize girebiliriz.
git init yazip enter yaparsak orada initializied by seklinde bir aciklama gorursek git icinde klasorumuz olusmus demektir. Bu sekilde projemizi git ile iliskilendirmis oluruz. Local repository’de calismalarimizi boyle depolamis oluruz. git init komutu ile dosyamiz icinde .git klasorunu goruruz. Boylece git ile baglanti kurduk.
Working Space: .git klasorunun bulundugu calisma alanidir. Klasorler ve dosylara uzerinden degisiklik burada yapilir. Az once yaptigimiz islemlerle .git klasorumuz olustu. Bu klasor bizim icin working space’dir.
Staging Area: Versiyon olusturulacak olan dosya veya klasorlerin gecici olarak toplandigi yerdir. Versiyon(commit) olusturulduktan sonra otomatik olarak staging area bosaltilir. Staging area bir bekleme salonu gibi dusunulebilir. Henuz bir degisiklik yapmadik ancak degisiklik yapmayi dusundugumuz bolumleri gecici olarak bu alanda tutariz.
Commit Store: git’in komutlarini kullanarak degisiklik sonrasinda olusan versiyonlari kaydederiz. Commit Store, commitlerimizin tutuldugu, depolandigi alandir.
Working space repository oluyor. Stage ve commit store .git klasorunde yer alir.
Working Space’den Staging Area’ya bir dosyadaki bir degisiklik nedeniyle gitmek icin git add ve dosya adini yazariz veya tum dosyalardaki degisiklikleri gondermek istersek sadece git add . seklinde yazariz. Boylece working Space’deki degisiklikler Staging Area’ya tasinmis oldu.
Staging Area’dan Commit Store’a giderken git commit -m”bir mesaj” yazariz. Commit demek version demektir. git init komutu bize stage area ve commit store’u olusturdu.
Text’imizde ekleme yaptiktan sonra git status yaziyoruz terminalde ve boylece son durumu gormus oluruz. Bu asamada degismis hali staging area’ya gecmis oldu.
Bir dosyamiz icin hic add komutunu kullanmadiysak untracked seklinde bir aciklama goruruz. Bir kere add komutunu kullandiysak artik bu dosya uzerinde degisiklik yapilmasi hallerinde dosyamiz modified asamasinda olur. Bir dosya uzerindeki degisiklik staging area’ya git add  , tum degisiklikleri staging area’ya git add . ile almis oluruz.
Artik bir version olusturmak istersek versiyonlari commit olarak adlandiririz. Git commit -m” “ tirnak isareti icine o degisiklige, projeye uygun bir mesaj yazilmali.
Dosyamiz uzerinde degisiklik yaptiktan sonra hem git add hem git commit komutlarini kullanmak istersek git commit -am”v2” yazariz. Bu sekilde hic beklemeden degisikligi staging area’dan commit store’a almis olduk. Ancak bu komutu kullanabilmemiz icin bir kere git add komutu kullanilmis olmali. Bu komut sonrasinda terminalde yaptigimiz ekleme ve cikarmadan bahsedilecek sekilde aciklama goruruz.
git commit --amend -m”” komutu, en son commit'i değiştirmek için kullanılır ve bu komutu kullanmadan önce bir değişiklik yaptıysanız, bu değişiklikler de son commit ile birleştirilir.
git status komutu ile genel durumu ne var ne yok diye soruyoruz.
git log ile tum degisiklikleri, versiyonlari kimin yaptigi, versiyonun olusturulma tarihleri ile birlikte detayli bilgilerini goruruz. Commit kelimesi devaminda her version icin ayri ayri kodlar var. Bunlara hashcode denir.
git log –online komutu mevcut versiyonlarin tum detaylari yerine mesajini ve hashcode’un ilk yedi karakterini gorebiliriz. Versiyonlar arasinda gezinti yaparken hashcode’larin ilk yedi karakterine ihtiyac duyariz. Bu 7 karakteri almak icin git log –online’I kullaniyoruz.
git log ve git log  --online ile degisiklik detaylarini tam olarak goremeyiz. Bunun icin git show komutunu kullaniriz.
git show komutunu hashcode’un ilk 7 karakterini yazarak kullaniriz. Degisiklik olarak neyi eklediysek onu bir metin halinde gorebiliyoruz. 7 karakteri oncesinde git log –online yazinca gormustuk ve git show yanina o 7 karakteri ekledik.
git add ile birlikte degisiklik yapilan dosya ismi yazilirsa, bu dosyayi uzantisi ile birlikte yazariz, ornegin text ise dosya adi nokta koyarak txt, word belgesi ise ismi nokta ve devaminda doc, java script ise nokta java yazilmali.
git init Repo olusturur ve her projede en basta bir kere kullanilir.
Commit Store & Head:
git log –oneline kullandigimizda bize head’I isaret etti. Bu Head nedir? En son icinde bulundugumuz, aktif olan commitimiz head olarak kabul ediliyor.
git restore ve bir bosluk devaminda dosyanin adini yaziyoruz. Once git status ile mevcut durumumuzu goruntuledik. git1 ve git2 dosyalarimizda degisiklik yapildigi, modified edildigini ancak degisikliklerin eklenmedigi uyarisini gorduk. Daha sonra git restore dosya adi yazdik enter sonrasi bu defa git status ile mevcut duruma bird aha baktik. git1 dosyamizdaki degisikligin iptal edildigini gorduk.
Ancak her iki dosyada da degisikligi iptal etmek istersek git restore . yazmaliyiz. Bu komut sonucunda git1 dosyamizi ve git2 dosyamizi control edince son degisikliklerin her iki dosyada da silindigini gorduk.

.git klasoru working Space’de bulunur. Calismalarimizi ve degisikliklerini emin oluncaya kadar Staging Area’da tutariz. Emin olduktan sonra calismalarimizi Commit Store’a gondeririz. Commit Store#a bir commit komutu ile gondeririz.
Bir dosyadaki degisiklikleri git add veya tum degisiklikleri git add . ile working space’den staging area’ya gondeririz. Son durumu git status komutunu kullaniriz. Dosyamda degisiklik var mi, modified mi, dosyam untracked mi yani ulasilamamis mi onlari goruruz.
Working Space’de yani proje klasorumuzdeki bir degisiklik icin (git restore), tum degisiklikler icin (git restore .) komutunu kullaniriz ve degisiklikleri sileriz.
Staging Area’daki yapmis oldugumuz degisiklikleri nasil iptal edebilir, geriye working space’a nasil alabiliriz? Spesifik bir dosyadaki degisiklik icin git restore --staged, tum degisiklikler icin git restore –staged . kullaniriz ve silme islemini saglariz.
Dosyalarimizda yaptigimiz degisikliklerden sonra terminale girdik ve git status ile duruma bakmak istedigimizde kirmizi renkle modified: git1.txt ve modified git2.txt gorduk.
git add . komutu ile degisiklikleri staging area’ya almak istedik. Sonrasinda git status komutu ile duruma bakinca bu defa dosyalarimizin isimlerinin yesil rekle modified olarak yazildigini gorduk. Boylece degisikliklerin alinmis oldugunu anladik.
hem stageden hem de working spaceden degisiklikleri iptal etmek icin git reset --hard komutu kullanilir. Bu komut riskli komutlardandir. Degisiklikler bununla iptal edilirse degisiklikleri geri alamayiz.
Bir projeyi git ile iliskilendirince calismalarimizi ayri bir branch olusturarak gelistirebiliriz. Ana projemizi orjinal kodlarimiza yeni ozellikler ekleyince hatalardan olabildigince korumak icin master branch uzerinde calismak yerine yeni bir branch uzerinde calismak daha mantikli olur. Ayri bir branch icin projemizin bir kopyasini aliyoruz. Yeni ekledigimiz ozellikler master branch’imiza zarar vermeden calisiyorsa bu ozellikleri, versiyonlari master branch’e aktaririz. Ancak yeni branch’de calisirken sorun olursa master branch’imizi olumsuz bir sekilde etkilememis oluruz.
Projemiz uzerinde birden fazla yazilimci olarak birlikte calisabiliriz. Birimiz giris sayfasindan, digeri sign isinden sorumlu olabilir. Mevcut projemizin bu calismalarda etkilenmemesi icin master branch yerine her yazilimci kendi branch’i uzerinde calisir. Calismalarimiz sorunsuz calistiginda her yazilimci kendi calismasini ana dosyaya aktarir.
git branch [isim] ile yeni bir branch olustururuz. Ornek git branch Zeynep
tum branchlerimizi gorebilmek icin git branch komutunu yaziyoruz.
Aktif olan branch’i git status yazinca ornek on master branch uzerinde oldugumuzu gosterir. Aktif olan branch’in yaninda yildiz isareti olur.
Git checkout ve yanina isim ekleyince ismini yazdigimiz branch aktif hale gelir.
Stashing: Degisikligimizi gecici olarak hafizaya alma islemidir. Degisikligi henuz -commit haline getirmemis isek ya commitlememiz ya da git stash komutu ile degisikligi gecici olarak bir stash listine alir. Stash listindeki degisikligi almak icin git stash pop komutu ile geri alip kullanabiliriz.
git’i idea’nize entegre edeceginiz uygulamalar var ve bu sayede komutlari kullanabilirsiniz. Bu arayuzleri kullanabilmek icin oncelikle git’in temel mantigini ogrenmeniz ve bu komutlari nerede kullanmaniz gerektigini anlamalisiniz.
.gitignore: Birseyleri git haricinde birakmak istedigimizde soz konusu olur. Bazi dosyalarimizda ozel bilgileri tutabiliriz. Bu bilgilerin baskalarinca gorulmesini istemeyebiliriz. Bunlari version control sistemine dahil etmek istemeyebiliriz. Bu nedenle .gitignore isimli bir dosya olustururuz. Bu dosya icind egit’e dahil etmek istemediklerimizi
Out/
.idea/(.idea/ klasoru icindeki degisiklikleri takip etme diyoruz bu sekilde)
.idea_modules/
*.iml
*.ipr
*.iws yazarak dahil etmeyebiliriz.
Bunu nasil yapariz?
CloneProject’I actik ve RenACar clasorumuze girdik. Bu klasorumuz git ile iliskili. Sagi tiklayip yeni bir dosya actik. .gitignore olarak adini verince uzantisi ornek txt veya docs ile birlikte sildigimizden bu konuda emin olup olmayacagimizi soran bir pencere acilinca yes kismina bastik. Dosyamiz uzerinde bir cicek sekli gibi bir sembol gorundu. Bu text’i uzantisi ile acmadigimizdan. Bu dosyamiz icinde .idea/ ve sonrasinda yeni olusturacagimiz dosyanin ismini yazarak bu dosyanin ignore edilmesi, commitlenmemesi saglanir. .gitignore dosyasinda adini yazdigimiz dosyayi klasorumuz icinde sagi tiklayarak olusturduk ve icine bir seyler yazdik. Daha sonra terminale giderek git status yazilinca ornegin yeni dosyamiz gizlidosyam isimli dosyamizin gorulmedigini gorduk ve bu dosya ismi ile islem yapilmadigini anladik.
Merge Conflict :
Iki developer ayni projede calisirken kendi degisikliklerini ana projeye gonderebilir. Ancak projenin ayni sayfasi ve ayni satirda farkli degisiklikler yapilirsa burada degisiklikler nedenli cakisma olur. Bu conflict’I birini secerek cozmek gerekir. Ilgili developer ya da proje lideri kisa bir inceleme ile bir karar verebilir. Degisikligi duzeltebilir. Bu sekilde cakismalar yasamamak icin best practice sudur;
GitHub repo’da bir projemiz var. Main branch uzerinde calisma yapmayip, pull komutu ile oradaki commitleri kendi branch’imize getirip daha sonra yeni bir branch olusturup, onlar uzerinde calistiktan sonra calismamiz bitince dogrudan main branch’e gondermiyoruz, yine remote’daki kendi branch’imize gonderiyoruz. Main branch’de birlesmesi icin ilgili kisiye bir istek de bulunuyoruz. O kisi calismamizi inceledikten sonra merge islemini yapar.
Kendi branch’imizi olusturmadan remote’daki repomuzdan cekilmesi gerekli olan bir degisiklik var mi diye bakiyoruz. Git pull dedik ve cekilecek bir degisiklik olmadigini anlayinca kendi branch’imizi olusturduk. Branch’imiz uzerinde commitleri yapip push ile tekrar repoya gonderecegiz.
Conflict olusursa github tarafindan <<<<< HEAD(Current Change)
>>>>>>>>>>>>>(incoming Change
=============== gibi isaretler degisiklik yapilan dosyamiza eklenir. Once bu isaretleri siliyoruz ve her iki dosyadaki degisiklikleri iki dosyayi acarak inceliyoruz. Bize lazim olacak sekilde duzeltiyoruz, conflict olusturmayacak sekilde degisikligimizi birakiyoruz.
Bir conflict olusunca merge komutu calistirilmiyor. Resolve conflict secenegini github kisminda secince isaretli kismi cikariyoruz ve sag ust kosede resolve kismini secerek resolved yapiyoruz ve artik merging yapilmasi icin merging kismini tikliyoruz. Car dosyamizi kontrol edince merging isleminin yapildigini anliyoruz.
Code’u sectigimizde main secenegi yaninda branches’lerimiz gorunur. Orayi acinca main ve kendi branch’imiz gorulur. Hangisi ile islem yapacaksak lokalde o branch’i seceriz.
Lokalimizde conflict ile karsilasirsak; remote’da iken dosya uzerinde degisiklik yapiyoruz ve degisikligi commitliyoruz. Lokale geliyoruz, dosyamizi aciyoruz. Main branch’imizdeyiz ve Car dosyamiz uzerinde yeni degisiklikler yaptik ayni satirda. Daha sonra git commit -am”n3” seklinde commitleme yapiyoruz ve git pull ile remote’daki degisikligi locale cekiyoruz. Lokale gelince kendi branch’imize git checkout Zeynep komutu ile geciyoruz ve git merge main yazinca Car dosyasinda conflict oldugu uyarisini gorduk.
Car dosyamizi acinca 9, 13 ve 17. Satirda renklendirilmis olarak cakisma oldugu uyarisini gorduk ve onlari sildik, cakisma olamayacak sekilde duzelttik.
Remote’da bir conflict olusturmak icin kendi branch’imize git checkout kendi branch’imizi yazdik ve  car.txt dosyamizin 7. Satirinda bir degisiklik yaptik. github’da car.txt dosyasinda 7.satirda baska bir degisiklik yaptik. Kendi branch’imizdeki commitleri master branch ile merge yapmak istedigimizde birlestirme yapmadi. Pull request yap dendi. Pull request yapinca conflict oldugu belirtildi ve cozmemiz gerektigi tavsiye edildi. Car.txt dosyamizda github’in ekledigi satirlari sildik ve masa ustundeki klasorumuz icindeki degisiklikleri biraktik ve sag kosede resolve kismini tikladik. Resolved sonrasi yine sag ustte commit merge butonuna tikladik. Problem olmadigi anlasilinca merge pull request kismini tikladik ve daha sonra merging gerceklesmis oldu.
Github’daki repo icinde main brach’deki degisiklikleri pull komutu ile cekiyoruz ve yeni branch olusturup lokalimizde bu branch uzerinde calisiyoruz. Bir problem yoksa push komutu ile github repo’ya gonderiyoruz.
Remote’da repo silme islemi settings kismindaki uygun secenekler ile mumkun. Delete this repository secenegi var. Oraya repo’nun linkini yazariz.

